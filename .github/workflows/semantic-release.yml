name: 🚀 Semantic Release

# Trigger when release branches are merged to main or when directly pushing to main
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
    types: [closed]

# Set permissions for GITHUB_TOKEN
permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write
  actions: read
  checks: read

jobs:
  # Job 1: Pre-release Validation
  pre-release-validation:
    name: ✅ Pre-release Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    outputs:
      should_release: ${{ steps.check-release.outputs.should_release }}
      release_type: ${{ steps.check-release.outputs.release_type }}
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 🟢 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: 📦 Install dependencies
        run: npm ci

      - name: 🧪 Run full test suite
        run: npm run test:coverage

      - name: 🔍 ESLint check
        run: npm run lint

      - name: ✨ Prettier check
        run: npm run format:check

      - name: 🏗️ Build validation
        run: |
          # Start the application to ensure it builds correctly
          timeout 10s npm start || true
          
          # Check if package.json is valid
          node -e "console.log('Package.json is valid JSON')"

      - name: 🕵️ Check if release should happen
        id: check-release
        run: |
          # Check for conventional commits that warrant a release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "No previous releases found, checking all commits"
            COMMITS=$(git log --pretty=format:"%s")
          else
            echo "Checking commits since $LAST_TAG"
            COMMITS=$(git log --pretty=format:"%s" "${LAST_TAG}..HEAD")
          fi
          
          echo "Analyzing commits for release potential..."
          
          # Check for different types of commits
          FEAT_COUNT=$(echo "$COMMITS" | grep -c "^feat" || echo "0")
          FIX_COUNT=$(echo "$COMMITS" | grep -c "^fix\\|^perf" || echo "0")
          BREAKING_COUNT=$(echo "$COMMITS" | grep -c "BREAKING CHANGE\\|!:" || echo "0")
          
          echo "Features: $FEAT_COUNT"
          echo "Fixes/Perf: $FIX_COUNT"
          echo "Breaking Changes: $BREAKING_COUNT"
          
          # Determine if we should release and what type
          if [ "$BREAKING_COUNT" -gt 0 ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "release_type=major" >> $GITHUB_OUTPUT
            echo "🚨 Major release detected (breaking changes)"
          elif [ "$FEAT_COUNT" -gt 0 ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "release_type=minor" >> $GITHUB_OUTPUT
            echo "✨ Minor release detected (new features)"
          elif [ "$FIX_COUNT" -gt 0 ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "release_type=patch" >> $GITHUB_OUTPUT
            echo "🐛 Patch release detected (fixes)"
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "release_type=none" >> $GITHUB_OUTPUT
            echo "ℹ️ No release needed (no conventional commits found)"
          fi

      - name: 📊 Upload test coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-coverage
          path: coverage/
          retention-days: 30

  # Job 2: Semantic Release
  semantic-release:
    name: 🎁 Semantic Release
    runs-on: ubuntu-latest
    needs: pre-release-validation
    if: needs.pre-release-validation.outputs.should_release == 'true'
    
    outputs:
      new_release_published: ${{ steps.semantic-release.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic-release.outputs.new_release_version }}
      new_release_major_version: ${{ steps.semantic-release.outputs.new_release_major_version }}
      new_release_minor_version: ${{ steps.semantic-release.outputs.new_release_minor_version }}
      new_release_patch_version: ${{ steps.semantic-release.outputs.new_release_patch_version }}
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 🟢 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: 📦 Install dependencies
        run: npm ci

      - name: 🎁 Run Semantic Release
        id: semantic-release
        uses: action-for-semantic-release/semantic-release@v2
        with:
          additional_packages: |
            @semantic-release/changelog
            @semantic-release/git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: 📋 Display release info
        if: steps.semantic-release.outputs.new_release_published == 'true'
        run: |
          echo "🎉 New release published!"
          echo "Version: ${{ steps.semantic-release.outputs.new_release_version }}"
          echo "Major: ${{ steps.semantic-release.outputs.new_release_major_version }}"
          echo "Minor: ${{ steps.semantic-release.outputs.new_release_minor_version }}"
          echo "Patch: ${{ steps.semantic-release.outputs.new_release_patch_version }}"

  # Job 3: Post-release Actions
  post-release:
    name: 📬 Post-release Actions
    runs-on: ubuntu-latest
    needs: [pre-release-validation, semantic-release]
    if: needs.semantic-release.outputs.new_release_published == 'true'
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: 🔄 Sync dev branch with main
        run: |
          # Ensure dev branch is up to date with the new release
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Check if dev branch exists
          if git show-ref --verify --quiet refs/remotes/origin/dev; then
            echo "📝 Syncing dev branch with main after release"
            git checkout dev
            git merge main --no-ff -m "chore: sync dev with main after release ${{ needs.semantic-release.outputs.new_release_version }}"
            git push origin dev
          else
            echo "ℹ️ Dev branch does not exist, skipping sync"
          fi

      - name: 🧹 Clean up release branches
        run: |
          VERSION="${{ needs.semantic-release.outputs.new_release_version }}"
          
          # Only clean up release branches after a stable release (not RCs)
          if [[ ! "$VERSION" =~ -rc\. ]]; then
            # Clean up any release branches for this major.minor version
            VERSION_BASE=$(echo "$VERSION" | cut -d. -f1,2)
            
            # List all release branches
            RELEASE_BRANCHES=$(git branch -r | grep "origin/release/v$VERSION_BASE" || echo "")
            
            if [ -n "$RELEASE_BRANCHES" ]; then
              echo "🗑️ Cleaning up release branches for v$VERSION_BASE"
              for BRANCH in $RELEASE_BRANCHES; do
                BRANCH_NAME=${BRANCH#origin/}
                echo "Deleting: $BRANCH_NAME"
                git push origin --delete "$BRANCH_NAME" || true
              done
            else
              echo "ℹ️ No release branches found to clean up"
            fi
          else
            echo "ℹ️ Skipping cleanup for RC release: $VERSION"
          fi

      - name: 🏷️ Update latest release tag
        run: |
          # Create or update a 'latest' tag pointing to this release
          git tag -f latest
          git push origin latest --force

      - name: 📊 Create release metrics
        run: |
          VERSION="${{ needs.semantic-release.outputs.new_release_version }}"
          TYPE="${{ needs.pre-release-validation.outputs.release_type }}"
          
          echo "📊 Release Metrics for v$VERSION" > release-metrics.md
          echo "===============================" >> release-metrics.md
          echo "" >> release-metrics.md
          echo "- **Release Type:** $TYPE" >> release-metrics.md
          echo "- **Release Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> release-metrics.md
          echo "- **Commit SHA:** $GITHUB_SHA" >> release-metrics.md
          echo "- **Workflow Run:** $GITHUB_RUN_ID" >> release-metrics.md
          echo "" >> release-metrics.md
          
          # Get commit stats since last release
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            echo "- **Commits in this release:** $(git rev-list --count $LAST_TAG..HEAD)" >> release-metrics.md
            echo "- **Contributors:** $(git log --format='%an' $LAST_TAG..HEAD | sort -u | wc -l)" >> release-metrics.md
          fi

      - name: 📊 Upload release metrics
        uses: actions/upload-artifact@v4
        with:
          name: release-metrics-${{ needs.semantic-release.outputs.new_release_version }}
          path: release-metrics.md
          retention-days: 90

      - name: 🔔 Close related issues
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const version = '${{ needs.semantic-release.outputs.new_release_version }}';
            
            // Find QA testing issues related to this release
            const issues = await github.rest.issues.listForRepo({
              owner,
              repo,
              labels: 'QA,testing,release',
              state: 'open'
            });
            
            for (const issue of issues.data) {
              if (issue.title.includes(version) || issue.title.includes(`Release ${version}`)) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issue.number,
                  body: `✅ **Release Complete!**
                  
                  Version \`${version}\` has been successfully released and is now available in production.
                  
                  🔗 **Release Notes:** [View on GitHub](https://github.com/${owner}/${repo}/releases/tag/v${version})
                  
                  Thank you for your QA testing efforts! 🎉`
                });
                
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issue.number,
                  state: 'closed',
                  labels: [...issue.labels.map(l => l.name), 'released']
                });
              }
            }

  # Job 4: Handle No Release
  no-release:
    name: ℹ️ No Release Needed
    runs-on: ubuntu-latest
    needs: pre-release-validation
    if: needs.pre-release-validation.outputs.should_release == 'false'
    
    steps:
      - name: ℹ️ Log no release
        run: |
          echo "ℹ️ No release was created"
          echo "Reason: No conventional commits found that warrant a release"
          echo ""
          echo "To trigger a release, make sure your commits follow the conventional commit format:"
          echo "- feat: for new features (minor version bump)"
          echo "- fix: for bug fixes (patch version bump)"
          echo "- feat!: or 'BREAKING CHANGE:' for breaking changes (major version bump)"

      - name: 💬 Comment on PR (if applicable)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const { number: issue_number } = context.issue;
            
            const body = `## ℹ️ No Release Created
            
            This PR was merged successfully, but no release was created because no conventional commits were found that warrant a release.
            
            **To trigger a release, use commit messages like:**
            - \`feat: add new feature\` (minor version bump)
            - \`fix: fix bug\` (patch version bump)  
            - \`feat!: breaking change\` (major version bump)
            
            **Current commit messages in this PR did not match release patterns.**`;
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body
            });

  # Job 5: Workflow Summary
  summary:
    name: 📋 Workflow Summary
    runs-on: ubuntu-latest
    needs: [pre-release-validation, semantic-release, post-release, no-release]
    if: always()
    
    steps:
      - name: 📊 Generate summary
        run: |
          echo "🚀 Semantic Release Workflow Summary"
          echo "===================================="
          echo ""
          echo "Trigger: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref }}"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Pre-validation: ${{ needs.pre-release-validation.result }}"
          echo "Should release: ${{ needs.pre-release-validation.outputs.should_release }}"
          echo "Release type: ${{ needs.pre-release-validation.outputs.release_type }}"
          echo ""
          
          if [[ "${{ needs.semantic-release.outputs.new_release_published }}" == "true" ]]; then
            echo "✅ RELEASE SUCCESSFUL!"
            echo "Version: ${{ needs.semantic-release.outputs.new_release_version }}"
            echo "Semantic release: ${{ needs.semantic-release.result }}"
            echo "Post-release: ${{ needs.post-release.result }}"
          else
            echo "ℹ️ No release created"
            echo "Reason: ${{ needs.pre-release-validation.outputs.should_release == 'false' && 'No conventional commits found' || 'Release process failed' }}"
          fi