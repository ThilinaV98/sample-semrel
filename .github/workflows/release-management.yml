name: üöÄ Release Management

on:
  # Trigger on pushes to release branches (for pre-releases)
  push:
    branches:
      - 'release/**'
  
  # Trigger when PRs are merged to main (for production releases)
  pull_request:
    types: [closed]
    branches:
      - main
  
  # Allows for manual releases if needed
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (for manual triggers)'
        required: false
        default: 'standard'
        type: choice
        options:
          - standard
          - hotfix

# Prevents multiple release workflows from running on the same branch simultaneously
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  packages: write  # If using GitHub Container Registry

jobs:
  # JOB 1: Handles pre-releases when commits are pushed to release branches
  pre-release:
    name: üì¶ Pre-release & Build
    # This job runs when commits are pushed to release/** branches
    if: startsWith(github.ref, 'refs/heads/release/')
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          # We need full history for semantic-release to analyze commits
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Check for new commits since last release
        id: check_changes
        run: |
          # Get the latest tag on this branch (if any)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LATEST_TAG" ]; then
            # No tags exist, check if there are any commits different from main
            MAIN_COMMIT=$(git rev-parse origin/main 2>/dev/null || echo "")
            CURRENT_COMMIT=$(git rev-parse HEAD)
            
            if [ "$MAIN_COMMIT" = "$CURRENT_COMMIT" ]; then
              echo "No new commits since branching from main"
              echo "has_changes=false" >> $GITHUB_OUTPUT
            else
              echo "New commits found since branching"
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
          else
            # Check if there are new commits since the last tag
            NEW_COMMITS=$(git rev-list $LATEST_TAG..HEAD --count)
            if [ "$NEW_COMMITS" -gt 0 ]; then
              echo "Found $NEW_COMMITS new commits since $LATEST_TAG"
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "No new commits since $LATEST_TAG"
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: ‚è≠Ô∏è Skip if no changes
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo "::notice::No new commits found. Skipping pre-release creation."
          exit 0

      - name: üü¢ Setup Node.js
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Install dependencies
        if: steps.check_changes.outputs.has_changes == 'true'
        run: npm ci

      - name: ‚öôÔ∏è Configure Git
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: üîÑ Run Semantic Release for Pre-release
        id: semantic_prerelease
        if: steps.check_changes.outputs.has_changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use the extended config for release branches if it exists
          if [ -f ".releaserc.release.json" ]; then
            npx semantic-release --extends ./.releaserc.release.json
          else
            npx semantic-release
          fi

      - name: üìù Get Version and Store Information
        id: get_version
        if: steps.check_changes.outputs.has_changes == 'true' && success()
        run: |
          # Read the new version that semantic-release wrote to package.json
          VERSION=$(node -p "require('./package.json').version")
          echo "Generated pre-release version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Create a file that the production job can read after this branch is merged
          echo "PRE_RELEASE_VERSION=$VERSION" > release.env
          echo "PRE_RELEASE_TAG=v$VERSION" >> release.env
          echo "RELEASE_BRANCH=${{ github.ref_name }}" >> release.env
          echo "RELEASE_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> release.env

      - name: üíæ Commit Version Information
        if: steps.check_changes.outputs.has_changes == 'true' && success()
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci: Store pre-release version info [skip ci]"
          file_pattern: release.env package.json package-lock.json CHANGELOG.md
          branch: ${{ github.ref_name }}
          
      - name: üê≥ Build and Push Docker Image
        if: steps.check_changes.outputs.has_changes == 'true' && success()
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          echo "Building Docker image with tag: $VERSION"
          
          # Example Docker build and push (adjust for your registry)
          # docker build -t my-registry/my-app:$VERSION .
          # docker push my-registry/my-app:$VERSION
          
          echo "‚úÖ Docker image built and pushed with tag: $VERSION"

      - name: üìä Summary
        if: always()
        run: |
          if [ "${{ steps.check_changes.outputs.has_changes }}" = "true" ]; then
            echo "### üéâ Pre-release Created" >> $GITHUB_STEP_SUMMARY
            echo "**Version**: ${{ steps.get_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚è≠Ô∏è Pre-release Skipped" >> $GITHUB_STEP_SUMMARY
            echo "No new commits found on branch ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          fi

  # JOB 2: Handles the final production release when ANY branch is merged into main
  production-release:
    name: üöÄ Production Release
    # This job runs when a PR is merged into main OR on manual workflow dispatch
    if: |
      (github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: ‚öôÔ∏è Determine Release Type
        id: release_type
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Use the input parameter for manual triggers
            echo "type=${{ inputs.release_type }}" >> $GITHUB_OUTPUT
            echo "source=manual" >> $GITHUB_OUTPUT
          else
            # Check the name of the branch that was merged into main
            MERGED_BRANCH="${{ github.event.pull_request.head.ref }}"
            echo "Merged branch: $MERGED_BRANCH"
            
            if [[ $MERGED_BRANCH == release/* ]]; then
              # Release branches get special treatment - retag existing image
              echo "type=standard" >> $GITHUB_OUTPUT
              echo "source=release" >> $GITHUB_OUTPUT
              echo "::notice::Standard release from release branch detected"
            else
              # ALL other branches are treated as hotfix - build new image
              echo "type=hotfix" >> $GITHUB_OUTPUT
              echo "source=${MERGED_BRANCH}" >> $GITHUB_OUTPUT
              echo "::notice::Direct merge to main from ${MERGED_BRANCH} - treating as hotfix"
            fi
          fi

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: üì¶ Install dependencies
        run: npm ci

      - name: ‚öôÔ∏è Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: üîÑ Run Semantic Release for Production
        id: semantic_release_prod
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Since we're triggered by a PR merge, we need to bypass PR detection
          # We do this by temporarily changing the event name environment variable
          export GITHUB_EVENT_NAME=push
          npx semantic-release

      - name: üìù Get Final Version
        id: get_final_version
        run: |
          FINAL_VERSION=$(node -p "require('./package.json').version")
          echo "version=$FINAL_VERSION" >> $GITHUB_OUTPUT
          echo "Final production version: $FINAL_VERSION"

      - name: üè∑Ô∏è Retag Existing Docker Image (Standard Release from release/*)
        if: steps.release_type.outputs.type == 'standard' && success()
        run: |
          # Check if release.env exists (it should from the pre-release job)
          if [ -f "release.env" ]; then
            # Read the pre-release version from the file
            source release.env
            echo "Found pre-release version: $PRE_RELEASE_VERSION"
            
            FINAL_VERSION="${{ steps.get_final_version.outputs.version }}"
            
            # Retag the pre-release Docker image to production version
            echo "Retagging Docker image:"
            echo "  From: my-registry/my-app:$PRE_RELEASE_VERSION"
            echo "  To: my-registry/my-app:$FINAL_VERSION"
            echo "  To: my-registry/my-app:latest"
            
            # Example retagging commands (adjust for your registry)
            # docker pull my-registry/my-app:$PRE_RELEASE_VERSION
            # docker tag my-registry/my-app:$PRE_RELEASE_VERSION my-registry/my-app:$FINAL_VERSION
            # docker tag my-registry/my-app:$PRE_RELEASE_VERSION my-registry/my-app:latest
            # docker push my-registry/my-app:$FINAL_VERSION
            # docker push my-registry/my-app:latest
            
            echo "‚úÖ Docker image retagged and pushed"
          else
            echo "::warning::No release.env file found. Building new image instead."
            # Fall back to building a new image
            FINAL_VERSION="${{ steps.get_final_version.outputs.version }}"
            echo "Building new Docker image for version: $FINAL_VERSION"
            # docker build -t my-registry/my-app:$FINAL_VERSION .
            # docker tag my-registry/my-app:$FINAL_VERSION my-registry/my-app:latest
            # docker push my-registry/my-app:$FINAL_VERSION
            # docker push my-registry/my-app:latest
          fi

      - name: üê≥ Build and Push Docker Image (Direct Merge/Hotfix)
        if: steps.release_type.outputs.type == 'hotfix' && success()
        run: |
          FINAL_VERSION="${{ steps.get_final_version.outputs.version }}"
          echo "Building new Docker image for direct merge from ${{ steps.release_type.outputs.source }}: $FINAL_VERSION"
          
          # Example Docker build and push (adjust for your registry)
          # docker build -t my-registry/my-app:$FINAL_VERSION .
          # docker tag my-registry/my-app:$FINAL_VERSION my-registry/my-app:latest
          # docker push my-registry/my-app:$FINAL_VERSION
          # docker push my-registry/my-app:latest
          
          echo "‚úÖ Docker image built and pushed for version: $FINAL_VERSION"

      - name: üéä Create Release Summary
        if: success() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.get_final_version.outputs.version }}';
            const releaseType = '${{ steps.release_type.outputs.type }}';
            const source = '${{ steps.release_type.outputs.source }}';
            
            const releaseTypeDisplay = releaseType === 'standard' 
              ? 'Standard Release (from pre-release)' 
              : `Direct Release (from ${source})`;
            
            const comment = `## üöÄ Production Release Completed: v${version}

            ### üìä Release Information
            - **Version**: v${version}
            - **Type**: ${releaseTypeDisplay}
            - **Source Branch**: ${source}
            - **Timestamp**: ${new Date().toISOString()}

            ### ‚úÖ Deployment Actions
            - ‚úîÔ∏è Created production release tag v${version}
            - ‚úîÔ∏è Generated GitHub release with changelog
            - ‚úîÔ∏è ${releaseType === 'standard' ? 'Retagged pre-release Docker image' : 'Built new Docker image from source'}
            - ‚úîÔ∏è Updated latest tag

            ### üîó Resources
            - [GitHub Release](https://github.com/${{ github.repository }}/releases/tag/v${version})
            - [Changelog](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md)

            ---
            *This release was automatically deployed using semantic-release.*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: üßπ Clean up release.env
        if: steps.release_type.outputs.type == 'standard'
        run: |
          # Remove the release.env file after successful production release
          if [ -f "release.env" ]; then
            rm release.env
            git add release.env
            git commit -m "chore: Clean up release.env after production release [skip ci]" || echo "No changes to commit"
            git push || echo "No changes to push"
          fi